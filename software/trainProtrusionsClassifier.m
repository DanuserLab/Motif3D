function trainProtrusionsClassifier(p)

% trainProtrusionsClassifier - given training data where a user clicked on protrusions, use an SVM to train a protrusion classifer
%
% p.mainDirectory - the directory within which clickPathList directories
%                   are contained
%
% p.clicksPathList - a cell array of the directories with training, the 
%                    directories are assumed to contain the output of 
%                    clickOnBlebs.m
% 
% p.MDsPathList - a cell array of the directories of the MovieData objects
%                 corresponding to p.clicksPathList
%
% p.saveDirectory - the directory where the SVM will be saved
%
% p.saveNameModel - the name of the saved SVM model
%
% p.saveNameCells - the name of the saved set of protrusion data
%
% p.usePatchMerge - set to 1 to use the surface segmentation generated by
%                   patchMerge rather than surfaceSegemnt
%
%
% Copyright (C) 2024, Danuser Lab - UTSouthwestern 
%
% This file is part of Morphology3DPackage.
% 
% Morphology3DPackage is free software: you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation, either version 3 of the License, or
% (at your option) any later version.
% 
% Morphology3DPackage is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
% 
% You should have received a copy of the GNU General Public License
% along with Morphology3DPackage.  If not, see <http://www.gnu.org/licenses/>.
% 
% 

% define usePatchMerge if needed
if ~isfield(p, 'usePatchMerge')
    p.usePatchMerge = 0;
end

% make a directory to save data in
if ~isdir(p.saveDirectory), mkdir(p.saveDirectory); end

% set the name of the directory within which to store user click data
clickDirName = 'TrainingData';

% iterate through the click paths
allMeasures = []; allProtrusions = []; 
clickedOnProtrusions = cell(length(p.clicksPathList),1); clickedOnNotProtrusions = cell(length(p.clicksPathList),1);
for c = 1:length(p.clicksPathList)
    
    % load the bleb location and other clicker data
    locationsPath = fullfile(p.mainDirectory, p.clicksPathList{c}, 'blebLocs.mat');
    load(locationsPath);  % loads frameIndex, chanIndex, and locations{}
    
    % determine the number of classes
    if isfield(locations{frameIndex(1)}, 'protrusions')
        numClasses = 1 + length(locations{frameIndex(1)}.protrusions);
    else
        numClasses = 2;
    end
    
    % determine what clickMode was used to select blebs
    if numClasses == 2
        if isfield(locations{1}, 'blebs') && isfield(locations{frameIndex(1)}, 'notBlebs')
            clickMode = 'clickOnCertain';
        elseif isfield(locations{1}, 'notBlebs')
            clickMode = 'clickOnAllNot';
        else 
            clickMode = 'clickOnAll';
        end
    else % for more than two classes the clickMode must be certain
        clickMode = 'clickOnCertain';
    end
    
    % initialize clickedOnProtrusions
    clickedOnProtrusions{c} = cell(length(frameIndex),1);
    clickedOnNotProtrusions{c} = cell(length(frameIndex),1);
    
    % load the movieData object
    try 
        mdName = dir(fullfile(p.mainDirectory, p.MDsPathList{c}, '*.mat'));
        load(fullfile(p.mainDirectory, p.MDsPathList{c}, mdName.name));
    catch
        disp('The provided MD path is not the path to a Matlab variable');
    end
    
    % for backwards compatibility
    meshProcessIndex = MD.packages_{1}.getProcessIndexByName('Mesh3DProcess');
    chan = MD.packages_{1}.processes_{meshProcessIndex}.funParams_.channels(1);
    if strcmp(chan, 'a'), chan = 1; end
    chanIndex = chan*ones(length(frameIndex), 1);
    
    % setup paths to data 
    analysisPath = fullfile(p.mainDirectory, p.MDsPathList{c}, 'Morphology', 'Analysis');
    surfacePath = fullfile(analysisPath, 'Mesh');
    if p.usePatchMerge == 1
        surfaceSegmentPath = fullfile(analysisPath,'PatchMerge');
    else
        surfaceSegmentPath = fullfile(analysisPath,'SurfaceSegment');
    end
    deconParamPath = fullfile(analysisPath,'Parameters', 'deconParameters.mat');
    
    % load the curvature segmentation statistics
    try
        csStatStruct = load(fullfile(analysisPath, 'PatchDescribe', 'segmentStats.mat'));
    catch % for backwards compatibility
        csStatStruct = load(fullfile(analysisPath, 'BlebSegment', 'segmentStats.mat'));
    end
    stats = csStatStruct.segmentStats; cellStats = csStatStruct.cellStats;
    
    % load the decon parameters
    try
        saveP = p; load(deconParamPath); p = saveP;
    catch
        weinerEstimateList = ones(1,MD.nFrames_);
    end
    if ~exist('weinerEstimateList', 'var'), weinerEstimateList = ones(1,MD.nFrames_); end

    % iterate through the frames
    for f = 1:length(frameIndex)
        
        % load the mesh 
        sStruct = load(fullfile(surfacePath, sprintf('surface_%i_%i.mat', chanIndex(f), frameIndex(f))));
        mesh = sStruct.surface;
        
        % load the surface segmentation
        csStruct = load(fullfile(surfaceSegmentPath, sprintf('surfaceSegment_%i_%i.mat', chanIndex(f), frameIndex(f))));
        if p.usePatchMerge == 1
            segment = csStruct.surfaceSegmentPatchMerge;
        else
            segment = csStruct.surfaceSegment;
        end
        
        % measure the position of each face
        numFaces = size(mesh.faces,1);
        positions = zeros(numFaces,3);
        for face = 1:numFaces
            verticesFace = mesh.faces(face,:);
            positions(face,:) = (mesh.vertices(verticesFace(1),:) + mesh.vertices(verticesFace(2),:) + mesh.vertices(verticesFace(3),:))/3;
        end

        % make a kd-tree to store the mesh faces
        treeMesh = kdtree_build(positions);

        % make a list of bleb indices that have been clicked on for the clickOnAll mode
        if strcmp(clickMode, 'clickOnAll')
            
            % for backwards compatability
            if ~isfield(locations{f}, 'blebs')
                blebClickLocs = locations{f};
            else
                blebClickLocs = locations{f}.blebs;
            end
            
            clickedOnProtrusionsFrame = zeros(1,length(blebClickLocs));
            for b = 1:length(blebClickLocs)

                % find the closest face to the click
                faceIndex = kdtree_k_nearest_neighbors(treeMesh, blebClickLocs(b,:), 1);

                % find the bleb label of that watershed
                clickedOnProtrusionsFrame(b) = segment(faceIndex);
            
            end
            clickedOnProtrusionsFrame = unique(clickedOnProtrusionsFrame);
            clickedOnProtrusions{c,1}{f,1} = clickedOnProtrusionsFrame;
         
        % make a list of bleb indices that have been clicked on for the clickOnAllNot mode   
        elseif strcmp(clickMode, 'clickOnAllNot')
            
            clickedOnNotProtrusionsFrame = zeros(1,length(locations{f}.notBlebs));
            for b = 1:length(locations{f}.notBlebs)

                % find the closest face to the click
                faceIndex = kdtree_k_nearest_neighbors(treeMesh, locations{f}.notBlebs(b,:), 1);

                % find the bleb label of that watershed
                clickedOnNotProtrusionsFrame(b) = segment(faceIndex);
            
            end
            clickedOnNotProtrusionsFrame = unique(clickedOnNotProtrusionsFrame);
            clickedOnNotProtrusions{c,1}{f,1} = clickedOnNotProtrusionsFrame;
            
        % make a list of bleb indices that have been clicked on for the clickOnCertain mode
        elseif strcmp(clickMode, 'clickOnCertain')
            
            % for two classes (for backwards compatibility this section depends on the number of classes)
            if numClasses == 2
                
                % for the clicked on blebs
                clickedOnProtrusionsFrame = zeros(1,length(locations{f}.blebs));
                for b = 1:size(locations{f}.blebs,1)
                    
                    % find the closest face to the click
                    faceIndex = kdtree_k_nearest_neighbors(treeMesh, locations{f}.blebs(b,:), 1);
                    
                    % find the bleb label of that watershed
                    clickedOnProtrusionsFrame(b) = segment(faceIndex);
                end
                clickedOnProtrusionsFrame = unique(clickedOnProtrusionsFrame);
                clickedOnProtrusions{c,1}{f,1} = clickedOnProtrusionsFrame;
                
                % for the clicked on non-blebs
                clickedOnNotProtrusionsFrame = zeros(1,length(locations{f}.notBlebs));
                for b = 1:size(locations{f}.notBlebs,1)
                    
                    % find the closest face to the click
                    faceIndex = kdtree_k_nearest_neighbors(treeMesh, locations{f}.notBlebs(b,:), 1);
                    
                    % find the bleb label of that watershed
                    clickedOnNotProtrusionsFrame(b) = segment(faceIndex);
                end
                clickedOnNotProtrusionsFrame = unique(clickedOnNotProtrusionsFrame);
                clickedOnNotProtrusions{c,1}{f,1} = clickedOnNotProtrusionsFrame;
            
            elseif numClasses > 2
                
                % for the clicked on protrusions
                for n = 1:numClasses-1
                    clickedOnProtrusionsFrame{n} = zeros(1,size(locations{f}.protrusions{n},1));   
                    for b = 1:size(locations{f}.protrusions{n},1)

                        % find the closest face to the click
                        faceIndex = kdtree_k_nearest_neighbors(treeMesh, locations{f}.protrusions{n}(b,:), 1);

                        % find the patch label of that watershed
                        clickedOnProtrusionsFrame{n}(b) = segment(faceIndex);
                    end
                    clickedOnProtrusionsFrame{n} = unique(clickedOnProtrusionsFrame{n});
                    clickedOnProtrusions{n}{c,1}{f,1} = clickedOnProtrusionsFrame{n};
                end
                
                % for the clicked on non-protrusions
                clickedOnNotProtrusionsFrame = zeros(1,length(locations{f}.notProtrusions));
                for b = 1:size(locations{f}.notProtrusions,1)
                    
                    % find the closest face to the click
                    faceIndex = kdtree_k_nearest_neighbors(treeMesh, locations{f}.notProtrusions(b,:), 1);
                    
                    % find the patch label of that watershed
                    clickedOnNotProtrusionsFrame(b) = segment(faceIndex);
                end
                clickedOnNotProtrusionsFrame = unique(clickedOnNotProtrusionsFrame);
                clickedOnNotProtrusions{c,1}{f,1} = clickedOnNotProtrusionsFrame;
            
            end
            
        end
        
        % assemble segmentation statistics into a matrix
        inModel = 'all';
        measures = makeMeasuresMatrixSVM(stats, cellStats, inModel, weinerEstimateList, chanIndex(f), frameIndex(f), MD.pixelSize_);

        % determine which segmented regions are blebs
        index = stats{chanIndex(f),frameIndex(f)}.index;
        blebby = index;
        if strcmp(clickMode, 'clickOnAll')
            for cb = 1:length(clickedOnProtrusionsFrame)
                blebby(index == clickedOnProtrusionsFrame(cb)) = 0;
            end
            blebby = ~logical(blebby);
        elseif strcmp(clickMode, 'clickOnAllNot')
            for cb = 1:length(clickedOnNotProtrusionsFrame)
                blebby(index == clickedOnNotProtrusionsFrame(cb)) = 0;
            end
            blebby = logical(blebby);
        elseif strcmp(clickMode, 'clickOnCertain')
            if numClasses == 2
                for cb = 1:length(clickedOnProtrusionsFrame)
                    blebby(index == clickedOnProtrusionsFrame(cb)) = 0;
                end
                for cb = 1:length(clickedOnNotProtrusionsFrame)
                    blebby(index == clickedOnNotProtrusionsFrame(cb)) = -2;
                end
                blebby(blebby > 0) = -1;
                blebby = blebby+1;
            else % multiple classes
                blebby = zeros(size(index));
                for n = 1:numClasses-1
                    for cb = 1:length(clickedOnProtrusionsFrame{n})
                        blebby(index == clickedOnProtrusionsFrame{n}(cb)) = n;
                    end
                end
                for cb = 1:length(clickedOnNotProtrusionsFrame)
                    blebby(index == clickedOnNotProtrusionsFrame(cb)) = -1;
                end
            end
        end
        
        if strcmp(clickMode, 'clickOnCertain')  
            % subset the measures matrix
            newMeasures = []; newBlebby = [];
            for b = 1:length(blebby)
               if blebby(b) ~= 0
                   newMeasures = [newMeasures; measures(b,:)];
                   newBlebby = [newBlebby; blebby(b,:)];
               end
            end
            measures = newMeasures;
            newBlebby(newBlebby == -1) = 0;
            blebby = newBlebby;
        end
        
        % append data to the larger matrix
        allMeasures = [allMeasures; measures];
        allProtrusions = [allProtrusions; blebby];
        
    end
       
    % save the current cell's clickedOnProtrusions and clickedOnNotProtrusions in the cell's directory
    if strcmp(clickMode, 'clickOnAll')
        clickedOnProtrusionsCell = clickedOnProtrusions{c,1};
        save(fullfile(MD.outputDirectory_, clickDirName, [p.saveNameCells '.mat']), 'clickedOnProtrusionsCell');
    elseif strcmp(clickMode, 'clickOnAllNot')
        clickedOnNotProtrusionsCell = clickedOnNotProtrusions{c,1};
        save(fullfile(MD.outputDirectory_, clickDirName, [p.saveNameCells '.mat']), 'clickedOnNotProtrusionsCell');
    else
        clickedOnProtrusionsCell = clickedOnProtrusions{c,1};
        clickedOnNotProtrusionsCell = clickedOnNotProtrusions{c,1};
        save(fullfile(MD.outputDirectory_, clickDirName, [p.saveNameCells '.mat']), 'clickedOnProtrusionsCell', 'clickedOnNotProtrusionsCell');
    end
    
end

% train an SVM, with feature selection, on all the training data
disp('  building the svm');
reproducible = 1;
numReps = 10;
[SVMmodelAll, inModelAll, fsHistoryAll] = svmWithFeatureSelection(allMeasures, allProtrusions, reproducible, numReps);
%[SVMmodelAll, inModelAll, fsHistoryAll] = forestWithFeatureSelection(allMeasures, allProtrusions, reproducible, numReps);

% save the SVM model 
save(fullfile(p.saveDirectory,[p.saveNameModel '.mat']), 'SVMmodelAll', 'inModelAll', 'fsHistoryAll');

% save the list of all clickedOnProtrusions and clickedOnNotProtrusions
if strcmp(clickMode, 'clickOnAll')
    save(fullfile(p.saveDirectory,[p.saveNameCells '.mat']), 'clickedOnProtrusions');
elseif strcmp(clickMode, 'clickOnAllNot')
    save(fullfile(p.saveDirectory,[p.saveNameCells '.mat']), 'clickedOnNotProtrusions');
else
    save(fullfile(p.saveDirectory,[p.saveNameCells '.mat']), 'clickedOnProtrusions', 'clickedOnNotProtrusions');
end
